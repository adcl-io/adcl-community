# Copyright (c) 2025 adcl.io
# All Rights Reserved.
#
# This software is proprietary and confidential. Unauthorized copying,
# distribution, or use of this software is strictly prohibited.

"""
Exploit Validation Service - Verify successful exploitation with proof.

Single responsibility: Validate exploitation success with various proof methods.
Tier 2 (Backend Service) - Used by workflow engine to confirm exploits worked.

Follows ADCL principles:
- Single responsibility (validation only)
- Text-based results (JSON)
- Composable (can validate any exploit type)
"""

import re
from datetime import datetime
from typing import Dict, Any, Optional
from pydantic import BaseModel, Field

import httpx

from app.core.logging import get_service_logger

logger = get_service_logger("exploit.validation")


# =============================================================================
# DATA MODELS
# =============================================================================

class ValidationResult(BaseModel):
    """Result of exploit validation"""
    success: bool = Field(..., description="Validation successful")
    confidence: float = Field(..., description="Confidence score (0.0-1.0)")
    message: str = Field(..., description="Validation message")
    proof: Optional[str] = Field(None, description="Evidence of exploitation")
    method: str = Field(..., description="Validation method used")
    timestamp: str = Field(default_factory=lambda: datetime.now().isoformat())


# =============================================================================
# EXPLOIT VALIDATOR
# =============================================================================

class ExploitValidator:
    """
    Validate successful exploitation with various proof methods.

    Supports multiple validation strategies:
    - RCE validation (command output matching)
    - File upload validation (HTTP request verification)
    - SQL injection validation (marker detection)
    - Custom regex matching
    """

    async def validate_rce(
        self,
        command_output: str,
        expected_pattern: Optional[str] = None,
        command: Optional[str] = None
    ) -> ValidationResult:
        """
        Validate remote code execution.

        Args:
            command_output: Output from executed command
            expected_pattern: Regex pattern to match (optional)
            command: Command that was executed (for context)

        Returns:
            ValidationResult with success status and proof
        """
        if not command_output or not command_output.strip():
            return ValidationResult(
                success=False,
                confidence=0.0,
                message="No command output received",
                proof=None,
                method="rce_validation"
            )

        # Default RCE validation: look for uid/gid pattern
        if not expected_pattern:
            # Common patterns for successful RCE
            patterns = [
                r"uid=\d+.*gid=\d+",  # id command
                r"^root$",  # whoami returning root
                r"^[a-zA-Z0-9_-]+$",  # whoami returning any user
                r"/.*",  # pwd returning path
                r"Linux|Darwin|Windows",  # uname returning OS
            ]

            # Try all patterns
            for pattern in patterns:
                if re.search(pattern, command_output, re.MULTILINE):
                    return ValidationResult(
                        success=True,
                        confidence=1.0,
                        message=f"RCE confirmed - command executed successfully",
                        proof=command_output[:500],  # Limit proof size
                        method="rce_validation"
                    )

            # Has output but doesn't match expected patterns
            return ValidationResult(
                success=True,
                confidence=0.7,
                message="Command executed but output doesn't match expected patterns",
                proof=command_output[:500],
                method="rce_validation"
            )

        # Custom pattern validation
        match = re.search(expected_pattern, command_output, re.MULTILINE | re.DOTALL)

        if match:
            return ValidationResult(
                success=True,
                confidence=1.0,
                message=f"RCE confirmed - output matches expected pattern",
                proof=command_output[:500],
                method="rce_validation_custom_pattern"
            )
        else:
            return ValidationResult(
                success=False,
                confidence=0.3,
                message=f"Output doesn't match expected pattern: {expected_pattern}",
                proof=command_output[:500],
                method="rce_validation_custom_pattern"
            )

    async def validate_file_upload(
        self,
        target: str,
        uploaded_file_path: str,
        timeout: int = 5,
        expected_status: int = 200
    ) -> ValidationResult:
        """
        Validate successful file upload by requesting the file.

        Args:
            target: Target URL (base)
            uploaded_file_path: Path to uploaded file (relative)
            timeout: Request timeout
            expected_status: Expected HTTP status code

        Returns:
            ValidationResult with success status
        """
        url = f"{target.rstrip('/')}{uploaded_file_path}"

        try:
            async with httpx.AsyncClient(timeout=timeout) as client:
                response = await client.get(url)

                success = response.status_code == expected_status

                if success:
                    message = f"File upload confirmed - {uploaded_file_path} is accessible"
                    confidence = 1.0
                else:
                    message = f"File upload may have failed - HTTP {response.status_code}"
                    confidence = 0.3

                return ValidationResult(
                    success=success,
                    confidence=confidence,
                    message=message,
                    proof=f"HTTP {response.status_code}: {url}",
                    method="file_upload_validation"
                )

        except httpx.TimeoutException:
            return ValidationResult(
                success=False,
                confidence=0.0,
                message="Validation timeout - cannot verify file upload",
                proof=None,
                method="file_upload_validation"
            )
        except Exception as e:
            return ValidationResult(
                success=False,
                confidence=0.0,
                message=f"Validation error: {str(e)}",
                proof=None,
                method="file_upload_validation"
            )

    async def validate_sql_injection(
        self,
        response_data: str,
        injection_marker: str = "SQLI_TEST",
        expected_pattern: Optional[str] = None
    ) -> ValidationResult:
        """
        Validate SQL injection by checking for marker or pattern in response.

        Args:
            response_data: Response data from injection attempt
            injection_marker: Marker string to look for
            expected_pattern: Optional regex pattern

        Returns:
            ValidationResult with success status
        """
        if not response_data:
            return ValidationResult(
                success=False,
                confidence=0.0,
                message="No response data to validate",
                proof=None,
                method="sqli_validation"
            )

        # Check for injection marker
        if injection_marker in response_data:
            return ValidationResult(
                success=True,
                confidence=1.0,
                message="SQL injection confirmed - marker found in response",
                proof=response_data[:500],
                method="sqli_validation_marker"
            )

        # Check for SQL error messages (indicates injection point)
        sql_error_patterns = [
            r"SQL syntax",
            r"mysql_fetch",
            r"ORA-\d{5}",
            r"PostgreSQL.*ERROR",
            r"Warning.*mysql",
            r"SQLite.*Exception"
        ]

        for pattern in sql_error_patterns:
            if re.search(pattern, response_data, re.IGNORECASE):
                return ValidationResult(
                    success=True,
                    confidence=0.8,
                    message="SQL injection likely - SQL error message detected",
                    proof=response_data[:500],
                    method="sqli_validation_error_detection"
                )

        # Custom pattern validation
        if expected_pattern:
            match = re.search(expected_pattern, response_data, re.MULTILINE | re.DOTALL)
            if match:
                return ValidationResult(
                    success=True,
                    confidence=1.0,
                    message="SQL injection confirmed - custom pattern matched",
                    proof=response_data[:500],
                    method="sqli_validation_custom_pattern"
                )

        return ValidationResult(
            success=False,
            confidence=0.1,
            message="No SQL injection indicators found",
            proof=response_data[:200],
            method="sqli_validation"
        )

    async def validate_custom(
        self,
        data: str,
        validation_config: Dict[str, Any]
    ) -> ValidationResult:
        """
        Custom validation based on configuration.

        Args:
            data: Data to validate
            validation_config: Validation configuration
                {
                    "method": "regex_match",
                    "pattern": "...",
                    "success_message": "...",
                    "failure_message": "..."
                }

        Returns:
            ValidationResult
        """
        method = validation_config.get("method", "regex_match")
        pattern = validation_config.get("pattern")
        success_message = validation_config.get("success_message", "Validation passed")
        failure_message = validation_config.get("failure_message", "Validation failed")

        if method == "regex_match" and pattern:
            match = re.search(pattern, data, re.MULTILINE | re.DOTALL)

            if match:
                return ValidationResult(
                    success=True,
                    confidence=1.0,
                    message=success_message,
                    proof=data[:500],
                    method="custom_validation_regex"
                )
            else:
                return ValidationResult(
                    success=False,
                    confidence=0.0,
                    message=failure_message,
                    proof=data[:500],
                    method="custom_validation_regex"
                )

        elif method == "contains":
            substring = validation_config.get("substring", "")
            if substring in data:
                return ValidationResult(
                    success=True,
                    confidence=1.0,
                    message=success_message,
                    proof=data[:500],
                    method="custom_validation_contains"
                )
            else:
                return ValidationResult(
                    success=False,
                    confidence=0.0,
                    message=failure_message,
                    proof=data[:500],
                    method="custom_validation_contains"
                )

        else:
            return ValidationResult(
                success=False,
                confidence=0.0,
                message=f"Unknown validation method: {method}",
                proof=None,
                method="custom_validation_error"
            )

    async def validate_from_workflow_output(
        self,
        workflow_output: Dict[str, Any],
        validation_config: Dict[str, Any]
    ) -> ValidationResult:
        """
        Validate exploit based on workflow output and validation config.

        This is the main entry point used by workflow engine.

        Args:
            workflow_output: Output from exploit node
            validation_config: Validation configuration from workflow

        Returns:
            ValidationResult
        """
        validation_method = validation_config.get("method", "rce")

        if validation_method == "rce" or validation_method == "command_execution":
            command_output = workflow_output.get("output", "")
            expected_pattern = validation_config.get("expected_pattern")
            command = workflow_output.get("command")

            return await self.validate_rce(
                command_output=command_output,
                expected_pattern=expected_pattern,
                command=command
            )

        elif validation_method == "file_upload" or validation_method == "http_request":
            target = workflow_output.get("target", "")
            path = validation_config.get("path", "/")
            expected_status = validation_config.get("expected_status", 200)

            return await self.validate_file_upload(
                target=target,
                uploaded_file_path=path,
                expected_status=expected_status
            )

        elif validation_method == "sqli" or validation_method == "sql_injection":
            response_data = workflow_output.get("output", workflow_output.get("response", ""))
            marker = validation_config.get("marker", "SQLI_TEST")
            expected_pattern = validation_config.get("expected_pattern")

            return await self.validate_sql_injection(
                response_data=response_data,
                injection_marker=marker,
                expected_pattern=expected_pattern
            )

        elif validation_method == "custom":
            data = workflow_output.get("output", str(workflow_output))
            return await self.validate_custom(
                data=data,
                validation_config=validation_config
            )

        else:
            logger.error(f"Unknown validation method: {validation_method}")
            return ValidationResult(
                success=False,
                confidence=0.0,
                message=f"Unknown validation method: {validation_method}",
                proof=None,
                method="unknown"
            )
