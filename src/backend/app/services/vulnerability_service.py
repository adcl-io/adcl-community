# Copyright (c) 2025 adcl.io
# All Rights Reserved.
#
# This software is proprietary and confidential. Unauthorized copying,
# distribution, or use of this software is strictly prohibited.

"""
Vulnerability Service - Vulnerability data management
Following ADCL principle: Backend service (Tier 2) - file-based storage, no MCP
"""
import json
import uuid
from pathlib import Path
from typing import List, Optional, Dict, Any
from datetime import datetime
from app.models.red_team import (
    Vulnerability,
    VulnerabilitySeverity,
    VulnerabilityFilters,
)


class VulnerabilityService:
    """
    Service for vulnerability data management.

    This is a Tier 2 backend service - manages vulnerability data on disk,
    provides querying and filtering capabilities.
    """

    def __init__(self, base_dir: str = "volumes/recon"):
        """
        Initialize vulnerability service.

        Args:
            base_dir: Base directory for vulnerability data
        """
        self.base_dir = Path(base_dir)
        self.base_dir.mkdir(parents=True, exist_ok=True)

        # Central vulnerability database file
        self.vuln_db_file = self.base_dir / "vulnerabilities.json"

        # Initialize database if it doesn't exist
        if not self.vuln_db_file.exists():
            self._init_database()

    def _init_database(self):
        """Initialize empty vulnerability database."""
        with open(self.vuln_db_file, "w") as f:
            json.dump([], f)

    async def add_vulnerability(
        self,
        cve: Optional[str],
        title: str,
        severity: VulnerabilitySeverity,
        host: str,
        port: Optional[int] = None,
        service: Optional[str] = None,
        description: Optional[str] = None,
        cvss: Optional[float] = None,
        exploitable: bool = False,
        exploit_available: bool = False,
        scan_id: Optional[str] = None,
    ) -> str:
        """
        Add a new vulnerability.

        Args:
            cve: CVE identifier
            title: Vulnerability title
            severity: Severity level
            host: Affected host
            port: Affected port
            service: Affected service
            description: Vulnerability description
            cvss: CVSS score
            exploitable: Whether exploitable
            exploit_available: Whether exploit is available
            scan_id: Associated scan ID

        Returns:
            Vulnerability ID
        """
        vuln_id = f"vuln_{uuid.uuid4().hex[:12]}"

        vuln = Vulnerability(
            vuln_id=vuln_id,
            cve=cve,
            title=title,
            severity=severity,
            cvss=cvss,
            host=host,
            port=port,
            service=service,
            description=description,
            exploitable=exploitable,
            exploit_available=exploit_available,
            discovered_at=datetime.now(),
            scan_id=scan_id,
        )

        # Load existing vulnerabilities
        vulns = self._load_vulnerabilities()

        # Add new vulnerability
        vulns.append(vuln.model_dump(mode="json"))

        # Save updated database
        self._save_vulnerabilities(vulns)

        return vuln_id

    async def get_vulnerability(self, vuln_id: str) -> Optional[Vulnerability]:
        """
        Get vulnerability by ID.

        Args:
            vuln_id: Vulnerability identifier

        Returns:
            Vulnerability object or None if not found
        """
        vulns = self._load_vulnerabilities()

        for vuln_data in vulns:
            if vuln_data.get("vuln_id") == vuln_id:
                try:
                    return Vulnerability(**vuln_data)
                except ValueError:
                    return None

        return None

    async def list_vulnerabilities(
        self, filters: VulnerabilityFilters
    ) -> List[Vulnerability]:
        """
        List vulnerabilities with filtering.

        Args:
            filters: Query filters

        Returns:
            List of vulnerabilities matching filters
        """
        vulns = self._load_vulnerabilities()
        results = []

        for vuln_data in vulns:
            try:
                vuln = Vulnerability(**vuln_data)

                # Apply filters
                if filters.severity and vuln.severity != filters.severity:
                    continue
                if filters.host and vuln.host != filters.host:
                    continue
                if filters.exploitable is not None and vuln.exploitable != filters.exploitable:
                    continue
                if filters.cve and vuln.cve != filters.cve:
                    continue

                results.append(vuln)

            except ValueError:
                # Skip invalid entries
                continue

        # Sort by severity (critical first) then by discovered time
        severity_order = {
            VulnerabilitySeverity.CRITICAL: 0,
            VulnerabilitySeverity.HIGH: 1,
            VulnerabilitySeverity.MEDIUM: 2,
            VulnerabilitySeverity.LOW: 3,
            VulnerabilitySeverity.INFO: 4,
        }

        results.sort(
            key=lambda v: (
                severity_order.get(v.severity, 999),
                v.discovered_at,
            ),
            reverse=True,
        )

        # Apply pagination
        return results[filters.offset : filters.offset + filters.limit]

    async def update_vulnerability(
        self, vuln_id: str, updates: Dict[str, Any]
    ) -> bool:
        """
        Update vulnerability data.

        Args:
            vuln_id: Vulnerability identifier
            updates: Fields to update

        Returns:
            True if updated successfully
        """
        vulns = self._load_vulnerabilities()
        updated = False

        for vuln_data in vulns:
            if vuln_data.get("vuln_id") == vuln_id:
                # Update fields
                for key, value in updates.items():
                    if key != "vuln_id":  # Don't allow ID changes
                        vuln_data[key] = value
                updated = True
                break

        if updated:
            self._save_vulnerabilities(vulns)

        return updated

    async def delete_vulnerability(self, vuln_id: str) -> bool:
        """
        Delete a vulnerability.

        Args:
            vuln_id: Vulnerability identifier

        Returns:
            True if deleted successfully
        """
        vulns = self._load_vulnerabilities()
        initial_count = len(vulns)

        # Filter out the vulnerability
        vulns = [v for v in vulns if v.get("vuln_id") != vuln_id]

        if len(vulns) < initial_count:
            self._save_vulnerabilities(vulns)
            return True

        return False

    async def get_vulnerability_count(self) -> Dict[str, int]:
        """
        Get count of vulnerabilities by severity.

        Returns:
            Dictionary mapping severity to count
        """
        vulns = self._load_vulnerabilities()

        counts = {
            "total": len(vulns),
            "critical": 0,
            "high": 0,
            "medium": 0,
            "low": 0,
            "info": 0,
        }

        for vuln_data in vulns:
            severity = vuln_data.get("severity", "").lower()
            if severity in counts:
                counts[severity] += 1

        return counts

    async def get_vulnerabilities_by_host(self, host: str) -> List[Vulnerability]:
        """
        Get all vulnerabilities for a specific host.

        Args:
            host: Host IP or hostname

        Returns:
            List of vulnerabilities for the host
        """
        vulns = self._load_vulnerabilities()
        results = []

        for vuln_data in vulns:
            if vuln_data.get("host") == host:
                try:
                    results.append(Vulnerability(**vuln_data))
                except ValueError:
                    continue

        return results

    async def get_vulnerabilities_by_scan(self, scan_id: str) -> List[Vulnerability]:
        """
        Get all vulnerabilities discovered by a scan.

        Args:
            scan_id: Scan identifier

        Returns:
            List of vulnerabilities from the scan
        """
        vulns = self._load_vulnerabilities()
        results = []

        for vuln_data in vulns:
            if vuln_data.get("scan_id") == scan_id:
                try:
                    results.append(Vulnerability(**vuln_data))
                except ValueError:
                    continue

        return results

    async def import_vulnerabilities_from_scan(
        self, scan_id: str, vulnerabilities: List[Dict[str, Any]]
    ) -> int:
        """
        Import vulnerabilities from a scan result.

        Args:
            scan_id: Scan identifier
            vulnerabilities: List of vulnerability data

        Returns:
            Number of vulnerabilities imported
        """
        count = 0

        for vuln_data in vulnerabilities:
            try:
                # Add scan_id if not present
                if "scan_id" not in vuln_data:
                    vuln_data["scan_id"] = scan_id

                # Generate ID if not present
                if "vuln_id" not in vuln_data:
                    vuln_data["vuln_id"] = f"vuln_{uuid.uuid4().hex[:12]}"

                # Add discovered timestamp if not present
                if "discovered_at" not in vuln_data:
                    vuln_data["discovered_at"] = datetime.now().isoformat()

                # Validate and add
                vuln = Vulnerability(**vuln_data)

                # Check for duplicates (same CVE/title/host/port)
                existing = await self._find_duplicate(vuln)
                if not existing:
                    vulns = self._load_vulnerabilities()
                    vulns.append(vuln.model_dump(mode="json"))
                    self._save_vulnerabilities(vulns)
                    count += 1

            except ValueError:
                # Skip invalid vulnerability data
                continue

        return count

    async def _find_duplicate(self, vuln: Vulnerability) -> bool:
        """Check if a similar vulnerability already exists."""
        vulns = self._load_vulnerabilities()

        for vuln_data in vulns:
            # Match by CVE and host if CVE is available
            if vuln.cve and vuln_data.get("cve") == vuln.cve and vuln_data.get("host") == vuln.host:
                return True

            # Otherwise match by title, host, and port
            if (
                vuln_data.get("title") == vuln.title
                and vuln_data.get("host") == vuln.host
                and vuln_data.get("port") == vuln.port
            ):
                return True

        return False

    # ========================================================================
    # Private helper methods
    # ========================================================================

    def _load_vulnerabilities(self) -> List[Dict[str, Any]]:
        """Load vulnerabilities from database file."""
        try:
            with open(self.vuln_db_file, "r") as f:
                return json.load(f)
        except (json.JSONDecodeError, FileNotFoundError):
            return []

    def _save_vulnerabilities(self, vulns: List[Dict[str, Any]]):
        """Save vulnerabilities to database file."""
        with open(self.vuln_db_file, "w") as f:
            json.dump(vulns, f, indent=2)
